# Day2. 자료구조와 알고리즘의 성능 1
::자료구조 + 알고리즘:: -> 코드(C, Java, Python…)로 구현
* 같은 코드라고 하더라도 HW/SW 환경에 따라 _상이한 성능_
* 다양한 크기의 입력 (같은 알고리즘, 다른 입력 -> 다른 성능)
**따라서 프로그램(자료구조+알고리즘)의 성능을 파악하기 위해서는 이러한 환경에 구애받지 않는 가상 컴퓨터 모델 필요**

**가상 컴퓨터(Virtual Machine) + 가상 언어(Pseudo language) + 가상 코드(Pseudo Code)**
-> 모두가 같은 환경에서 여러 알고리즘을 객관적으로 비교 가능
- - - -
## 가상 컴퓨터(Virtual Computer)
### Turing Machine: 최초의 가상 컴퓨터
* RAM(Random Access Machine) 모델: CPU + Memory + 기본 연산(단위 시간에 수행되는 연산들의 모음) -> _알고리즘(CPU/Memory를 사용해 기본 연산들을 반복)을 RAM에서 실행_

### 기본 연산: RAM 모델에서 단위 시간에 수행되는 연산
* 배정, 대입, 복사 연산: ‘A=B’로 초기화 할 때, B를 읽어 A에 쓰는 시간을 _단위 시간(1시간)에 수행_ 한다고 가정
* 산술 연산: +, —, *, /  _(※ %, 반올림, 올림, 버림 등은 아님)_
* 비교 연산: >, >=, <=, <, ==, !=
* 논리 연산: and, or, not
* bit-논리 연산: bit-and, bit-or, bit-not
- - - -
## 가상 언어(Pseudo/Virtual language)
* 가상 컴퓨터에서 **시뮬레이션**되는 코드.
-> _실제 작동이 아닌, 시뮬레이션_

### 포함해야 하는 구성 요소
* 배정, 산술, 비교, 논리, bit-논리 연산 등의 “기본 연산” -> 기존 언어 사용
* if, elif, else 구조의 비교, 제어, 명령어
* 반복문: for, while…
* 함수: 함수를 정의, 호출, return 할 수 있는 문법

### 가상 코드(Pseudo Code)
* 실제 실행할 수는 없으나 컴퓨터 언어와 유사한 수준에서 프로그램의 논리를 설명한 코드로, 실제 컴퓨터 언어에 구애받지 않고 간략하게 작성.
-> 이를 통해 직접 프로그램의 실행 방식을 확인하고 작동 시간 계산

Ex)
```
algorithm ArrayMax(A, n)
input: n개의 정수를 갖는 배열 A
output: 배열 A 중 최댓값 return

for i = 1 to n-1 do #A[1]부터 A[n-1]까지 시도
	if CurrentMax < A[i]:
		CurrentMax = A[i]
	return CurrentMax
```
위 경우에서 A = [3, -1, 9, 2, 12]일 경우
CurrentMax는 최초에 A[0]이기 때문에 3이 된다. 이 때 += 단위시간 1
A[1]인 -1과 비교하여 += 단위시간 1
A[2]인 9와 비교하여 += 단위시간 1
3 < 9이므로 CurrentMax에 9를 초기화하여 += 단위시간 1
A[3]인 2와 비교하여 += 단위시간 1
A[4]인 12와 비교하여 += 단위시간 1
9 < 12이므로 CurrentMax에 12를 초기화하여 += 단위시간 1
-> 총 기본연산을 총 _7회_ 반복했다.

※ 하지만 이 경우에도 n과 A에 대한 경우의 수는 무한하기 때문에 앞으로는 이에 대하여 어떻게 성능을 비교할 것인지 살펴볼 것이다.
