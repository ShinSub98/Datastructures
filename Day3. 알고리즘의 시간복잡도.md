# Day3. 알고리즘의 시간복잡도
## 시간복잡도
* **시간복잡도(Time Complexity)**: 알고리즘이 수행되는 시간
* input size: 알고리즘에 입력되는 데이터의 크기. (Ex. len(리스트) )
* 알고리즘의 시간복잡도를 구하는 방법
	1. 모든 입력에 대한 기본 연산 횟수를 더한 후 평균 -> 무한한 경우의 수 때문에 현실적으로 불가능
	2. **Worst time complexity**: 가장 연산이 많이 필요한 입력의 기본연산 횟수를 측정 -> _어떤 입력에 대해서도 WTC보다 수행시간이 짧다는 것을 보장할 수 있음._
-> ::알고리즘의 수행시간은 최악의 입력에 대한 기본연산 횟수::

## 시간복잡도 계산
* 알고리즘의 시간복잡도는 보통 **T(n)**으로 표현된다.
-> n은 input size

이전 시간의 algoritm MaxArray(A, n):의 T(n)은 2n-1이다.
(‘-1’은 최초 A[i]를 초기화 하는 경우의 수로 단 한 번의 연산만 필요하기 때문)

## Examples
### Case1
```
algorithm sum1(A,n):
	sum = 0
		for i = 0 to n-1 do
			if A[i] % 2 == 0:
				sum += A[i]
	return sum
```

* **최악의 경우**: A의 모든 값이 짝수인 경우

> 최초에 sum에 0을 초기화 하여 +1  
> A[i]와 2에 대한 나머지 연산을 매번 수행하므로 +n  
> A[i]%2가 0인지 확인하는 연산을 매번 수행하므로 +n  
> “sum += A[i]”의 문장은 “sum = sum + A[i]”라는 뜻이므로 ‘더하기’와 ‘저장’이라는 두 가지의 기본 연산을 수행하므로 +2n  
> 따라서 T(n) = 4n+1  


### Case2
```
algorithm sum2(A,n):
	sum = 0
		for i = 0 to n-1 do
			for j = i to n-1 do
				sum += A[i] * A[j]
	return sum
```

* **최악의 경우**: 조건문이 없기 때문에 ::모든 입력 경우의 수가 최악의 경우::

> 최초에 sum에 0을 초기화 하여 +1  
>   
> i의 반복문은 n번 반복 -> *n  
>   
> **여기서부터 중첩 반복문**  
> j 반복 1회 당 A[i]와 A[j]에 대한 곱하기를 매번 수행하므로 +n  
> 이후 sum에 더하므로 +n  
> 이후 sum에 sum + A[i]*A[j]를 저장하므로 +n  
> -> j 한 번에 총 3개의 기본 연산  
> **여기까지 j(= n-i)를 한 번 반복할 때의 시간복잡도**  
>   
> 이러한 j의 반복 횟수는 n, n-1, n-2 … 1까지 이어지기 때문에  
> n! = (n(n+1))/2로 표현할 수 있다.  
> 즉 이 중첩 반복문은 총 3(n(n+1))/2번 반복한다.  
>   
> 따라서 T(n) = 3(n(n+1))/2 + 1  
  
**Case1과 다르게 Case2의 n은 제곱의 형태이기 때문에 input size가 늘어날수록 Case1보다 더 빠르게 시간복잡도가 증가한다.**



#자료구조
